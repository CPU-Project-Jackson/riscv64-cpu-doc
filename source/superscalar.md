# 超标量流水线


```{note}
挖掘指令间潜在的并行性(ILP)主要有两种方法，一种是增加流水线的级数，一种是增加流水线内部的功能部件数量，这样可以每周期发出多条指令。
```

实现多发射处理器主要有两种方法，区别在于编译器和硬件的不同分工。如果指令发射与否的判断是在编译时完成的，成为静态多发射(static multiple issue)。如果指令的发射与否的判断是在动态执行过程中由硬件完成的，成为动态多发射(dynamic multiple issue)。

```{note}
动态多发射处理器也称为超标量处理器或朴素的超标量处理器。
```

许多超标量处理器扩展了动态发射逻辑的基础框架，形成了动态流水线调度技术。动态流水线调度技术由硬件逻辑选择当前周期内执行的指令，并尽量避免流水线的冒险和停顿。(即乱序)

为使得程序行为与简单的按序单发射流水线一致，乱序执行流水线的取指和译码都需要按序执行，以便正确处理指令间的相关。同样，提交阶段也需要按照取指的顺序依次将指令执行结果写入到寄存器和存储中。这种保守的处理方法称为**按序提交**。如果发生例外，处理器很容易能找到例外前的最后一条指令，也会保证只更新在此之前的指令需要改写的寄存器。虽然流水线的前端(取指和译码)和后端(提交阶段)都是按序执行，但是功能部件是允许乱序执行的。任何时候只要所需数据准备好，指令就可以被发射到功能部件开始执行。目前，所有动态调度的流水线都是按序提交的。


## 基础知识

本章节主要参考《计算机体系结构（第二版）》第6章“动态流水线”和第7章“多发射数据通路”

### 动态流水线

所谓静态，指的是不允许指令的乱序执行。动态流水线的核心思想就是允许超车，指令准备好了就执行，不用等侯前面不相关的指令

#### 影响流水线效率的因素

程序的执行时间等于程序中的指令数乘以CPI再乘以时钟周期。由于指令相关容易引起流水线的阻塞，因此CPI等于一条指令的理想周期数加上指令相关引起的阻塞周期数。

指令的相关性主要包括数据相关、控制相关和结构相关。其中数据相关又可以分成
* RAW(Read After Write)
* WAW(Write After Write)
* WAR(Write After Read)

RAW是真正的数据相关，因为指令之间存在着数据传递关系；WAW和WAR又称为假相关或名字相关，指令之间实际上不存在数据传递，因为名字相关并没有真正的数据交换，所以可以通过寄存器重命名来解决。

```{admonition} 寄存器重命名的设计思想
指令产生结果后不立即修改寄存器，而是先存起来等前面的指令都执行结束，保证不会发生例外或者转移取消时，才能修改寄存器
```

数据相关有时候特指RAW相关，RISC的兴起在很大程度上是因为在RISC结构中容易高效地判断指令间的数据相关，因为RISC是寄存器——寄存器型的，寄存器的数据相关比较容易判断，只要判断清楚了，就可以通过乱序执行来避免数据相关引起流水线阻塞。

存储器的相关不好判断，例如(R4) + 100指向的单元和(R6) + 20指向的单元在译码阶段不能判断其相关性，即使R4和R6的值已经读出来了，(R4) + 100和(R6) + 20不相等，也不能保证他们不相关，因为**他们表示的虚地址可能被映射到同一个物理地址**。

#### 指令调度技术

指令调度指的是不影响程序正确性的前提下，通过改变指令的执行次序来避免由于指令相关引起流水线阻塞。指令调度可以分为静态调度和动态调度。静态调度是由程序员和编译器在程序执行之前进行的指令调度；而动态调度是在程序执行过程中由硬件自动进行的指令调度。

```{admonition} 指令调度的基本思想
为了提高指令级并行的效率，通过寄存器重命名和指令重排来避免由于指令之间的数据相关和名字相关而引起的冲突
```

静态调度通过程序员或者编译器对指令进行精心埃列，把相关指令隔开，但其有以下几个问题
1. 编译器不是万能的，有些相关信息在编译时难以确定，比如访存操作之间是否存在相关或访存操作是否命中cache等。
2. 静态调度需要针对具体的流水线结构，针对某个流水线结构优化的代码在另一个流水线结构中不见得适用。

指令动态调度基本原理是：前面的指令由于相关而阻塞时，不阻塞后面不相关的指令。

#### Tomasulo算法

![tomasulo](_static/tomasulo.png)

在Tomasulo算法中，保留站还起到重命名寄存器的作用，通过寄存器重命名，指令和指令之间的寄存器相关变成了保留站之间的相关。

#### 例外和动态流水线

Tomasulo算法实现的非精确的例外。例外一旦出现，硬件就不好处理，尤其是一些多功能部件及多拍操作的例外处理比较困难。操作系统非常期望采用动态流水线的处理器能够提供精确例外。

所谓精确例外，就是在处理例外的时候，发生例外之前的所有指令都已经执行万了，例外指令后面的所有指令都还没有执行。

实现精确例外处理的方法就是把后面指令对机器状态的修改延迟到前面指令都已经执行完。具体来讲，在流水线中增加一个叫提交(Commit)的阶段，在这个阶段才真正的修改计算机的状态。在执行或者写回阶段，把指令的结果先写到被称为重排序(ReOrder Buffer,ROB)的临时缓冲区中，提交的时候，再把ROB的内容协会到寄存器或存储器。**ROB是微体系结构的概念，程序员时看不到的，程序员看得到的是计算机状态包括寄存器和存储器**

保留站和ROB是现在通用处理器的两个核心部件，他们两个的作用恰好相反：**保留站把有序变成乱序，ROB把乱序重新排回有序。**


```{note}
流水线的发展过程很有趣，一开始都是顺序执行；顺序效率不好，就发展到乱序执行；乱序在转移、例外时难以处理，又弄出ROB把顺序给找回来。这是一个顺序到乱序再到顺序的螺旋上升过程，通过这个过程，流水线的效率得到了极大的提升。现代处理器中的指令都是顺序进入、乱序执行、有序结束。保留站把顺序变成乱序，而ROB又把指令从乱序变为顺序。

### 多发射数据通路

#### 指令级并行技术

并行主要有三类技术：
1. 数据级并行(Data Level Parallelism, DLP)

	一条指令可以处理多个数据，最典型的就是向量指令。
2. 指令级并行(Instruction Level Parallelism, ILP)

	这种并行不需要修改程序(数据级并行就算需要重写程序)，而只需要修改硬件结构就可以提高性能。
	* 指令流水线通过时间重叠实现指令级并行，实际上是提高了频率
	* 多发射通过空间重复实现指令级并行
	* 乱序执行提高流水线的效率，挖掘指令间潜在的可重叠性或不相关性。
3. 线程级并行(Thread Level Parallelism, TLP)

	或者称为进程级并行，这是比较宏观的并行，现在多核技术都是这种并行。

#### 乱序执行的流水线通路

保留站可以采用独立、分组和全局3种结构，保留站和寄存器的关系有在保留站前读寄存器和在保留站后读寄存器两种情况，重命名寄存器可以独立于结构寄存器，也可以和结构寄存器一起合并成物理寄存器堆。

无论结构怎么设计，目标都是正确且高效地执行程序。只要搞清楚保留站的作用是能够乱序执行指令；ROB的作用是能够有序结束指令；重命名寄存器可以与ROB或者保留站结合，也可以与结构寄存器结合形成物理寄存器堆等，但是流水线结构的基本原理是不变的。

#### 多发射结构

多发射结构和单发射结构的区别首先在与他的指令和数据通路变宽了。

## 动手实践
